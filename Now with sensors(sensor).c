#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl2,  lift,           sensorTouch)
#pragma config(Sensor, dgtl12, shoot,          sensorTouch)
#pragma config(Motor,  port1,           LL3,           tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LL1,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           FL,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FR,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LR2,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LL2,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           BR,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           BL,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           LR3,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LR1,           tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma systemFile            	// eliminates warning for "unreferenced" functions

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]
int speed;


task intake() {
	while(true) {
		if (vexRT[Btn5U]){
			speed = -127;
			motor[LL1] = speed;
				motor[LL2] = speed;
				motor[LL3] = speed;
				motor[LR1] = speed;
				motor[LR2] = speed;
				motor[LR3] = speed;
			while( SensorValue[ shoot ] == 1 ) {
				speed = 0;
				motor[LL1] = speed;
				motor[LL2] = speed;
				motor[LL3] = speed;
				motor[LR1] = speed;
				motor[LR2] = speed;
				motor[LR3] = speed;

				if (vexRT[Btn5D]) {
				speed = -127;
				motor[LL1] = speed;
				motor[LL2] = speed;
				motor[LL3] = speed;
				motor[LR1] = speed;
				motor[LR2] = speed;
				motor[LR3] = speed;
				wait1Msec (200);
				speed = 0;
				motor[LL1] = speed;
				motor[LL2] = speed;
				motor[LL3] = speed;
				motor[LR1] = speed;
				motor[LR2] = speed;
				motor[LR3] = speed;

			}
			}

		}
	}
	motor[LL1] = speed;
	motor[LL2] = speed;
	motor[LL3] = speed;
	motor[LR1] = speed;
	motor[LR2] = speed;
	motor[LR3] = speed;

	if (vexRT[Btn6D]) {
		speed = 0;
		motor[LL1] = speed;
		motor[LL2] = speed;
		motor[LL3] = speed;
		motor[LR1] = speed;
		motor[LR2] = speed;
		motor[LR3] = speed;
	}
	else if (vexRT[Btn6U]) {
		speed = 127;
		motor[LL1] = speed;
		motor[LL2] = speed;
		motor[LL3] = speed;
		motor[LR1] = speed;
		motor[LR2] = speed;
		motor[LR3] = speed;
	}
}



void init () {
startTask(intake);
}



void pre_auton () {

}

task autonomous () {
}

task usercontrol() {
init();
while (true) {
	// Y component, X component, Rotation
	motor[FL] = -C1LY - C1LX - C1RX;
	motor[FR] =  C1LY - C1LX - C1RX;
	motor[BR] =  C1LY + C1LX - C1RX;
	motor[BL] = -C1LY + C1LX - C1RX;

	// Motor values can only be updated every 20ms
	wait10Msec(2);

}
}
